(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDom = factory(global.React));
})(this, (function (React) { 'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

	var workTags;
	(function (workTags) {
	    workTags[workTags["FunctionComponent"] = 0] = "FunctionComponent";
	    //render挂载的根节点
	    workTags[workTags["HostRoot"] = 3] = "HostRoot";
	    //div
	    workTags[workTags["HostComponent"] = 5] = "HostComponent";
	    // <div>123</div>中的123
	    workTags[workTags["HostText"] = 6] = "HostText";
	})(workTags || (workTags = {}));

	//
	var fiberFlags;
	(function (fiberFlags) {
	    fiberFlags[fiberFlags["NoFlags"] = 0] = "NoFlags";
	    fiberFlags[fiberFlags["Placement"] = 1] = "Placement";
	    fiberFlags[fiberFlags["Update"] = 2] = "Update";
	    fiberFlags[fiberFlags["ChildDeletion"] = 4] = "ChildDeletion";
	})(fiberFlags || (fiberFlags = {}));
	var fiberFlags$1 = fiberFlags;
	var fiberMask;
	(function (fiberMask) {
	    fiberMask[fiberMask["Mutation"] = 7] = "Mutation";
	})(fiberMask || (fiberMask = {}));

	class FiberNode {
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    return;
	    sibling;
	    child;
	    index;
	    ref;
	    memoizedPros;
	    memoizedState;
	    updateQueue;
	    alternate = null;
	    flags = fiberFlags$1.NoFlags;
	    subTreeFlags = fiberFlags$1.NoFlags;
	    constructor(tag, pendingProps, key) {
	        this.tag = tag;
	        this.key = key;
	        /**
	         * 对于HostCompent stateNode对应宿主环境中的节点。比如div
	         */
	        this.stateNode = null;
	        /**
	         * 对于FunctionCompent type对应函数组件的函数
	         */
	        this.type = null;
	        this.return = null;
	        this.sibling = null;
	        this.child = null;
	        /**
	         *这个FiberNode作为child时，对应的下标
	         */
	        this.index = 0;
	        this.ref = null;
	        /**
	         * 当前正在处理的Fiber的props
	         */
	        this.pendingProps = pendingProps;
	        /**
	         * pedningprops处理完成后变成memoizedPros
	         */
	        this.memoizedPros = null;
	        this.updateQueue = {
	            shared: { pending: null },
	            dispatch: null
	        };
	        this.alternate = null;
	        this.flags = fiberFlags$1.NoFlags;
	        this.subTreeFlags = fiberFlags$1.NoFlags;
	    }
	}
	/**
	 * @description 应用的根节点
	 * createRoot(A).render(B)中的 A对应了 container
	 * FiberRootNode.stateNode === A
	 * A.current  === FiberRootNode
	 */
	class FiberRootNode {
	    container;
	    current;
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	    }
	}
	/**
	 * @description
	 * 给定一个fiber，创建对应的alternate fiber
	 */
	const createWorkInProgress = (fiber, pendingProps) => {
	    let wip = fiber.alternate;
	    if (wip === null) {
	        wip = new FiberNode(fiber.tag, pendingProps, fiber.key);
	        wip.stateNode = fiber.stateNode;
	        wip.alternate = fiber;
	        fiber.alternate = wip;
	    }
	    else {
	        wip.pendingProps = pendingProps;
	        wip.flags = fiberFlags$1.NoFlags;
	    }
	    wip.type = fiber.type;
	    wip.updateQueue = fiber.updateQueue;
	    wip.child = fiber.child;
	    wip.memoizedPros = fiber.memoizedPros;
	    wip.memoizedState = fiber.memoizedState;
	    return wip;
	};
	function createFiberFromReactElement(reactElement) {
	    const { type, key, props } = reactElement;
	    let fiberTag = workTags.FunctionComponent;
	    if (typeof type === 'string') {
	        fiberTag = workTags.HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.error('未定义的 createFiberFromReactElement');
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	/**
	 * @description 创建update对象
	 * @param {SetStateAction} action
	 * @returns {Update} update
	 */
	function createUpdate(action) {
	    return {
	        action
	    };
	}
	function createUpdateQueue() {
	    return {
	        shared: {
	            pending: null
	        },
	        dispatch: null
	    };
	}
	function enqueueUpdate(updateQueue, update) {
	    updateQueue.shared.pending = update;
	}
	function processUpdateQueue(baseState, pendingUpdate) {
	    if (pendingUpdate == null)
	        return { memorizedState: baseState };
	    let result = baseState;
	    const action = pendingUpdate.action;
	    if (action instanceof Function) {
	        result = action(baseState);
	    }
	    else {
	        result = action;
	    }
	    return {
	        memorizedState: result
	    };
	}

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react') : 0xeac7;

	function ChildReconciler(shouldTrackEffects) {
	    function reconcileSingleElement(returnFiber, 
	    // currentFiber: FiberNode | null | undefined,
	    element) {
	        const fiber = createFiberFromReactElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function reconcileSingleTextNode(returnFiber, 
	    // currentFiber: FiberNode | null | undefined,
	    text) {
	        const fiber = new FiberNode(workTags.HostText, { text }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function placeSingleChild(fiber) {
	        if (shouldTrackEffects && fiber.alternate === null) {
	            fiber.flags |= fiberFlags$1.Placement;
	        }
	        return fiber;
	    }
	    function reconcileChildFibers(returnFiber, currentFiber, newChild) {
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, newChild));
	            }
	        }
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcileSingleTextNode(returnFiber, newChild));
	        }
	        return null;
	    }
	    return { reconcileChildFibers };
	}
	const reconcileChildFibers = ChildReconciler(true).reconcileChildFibers;
	const mountChildFibers = ChildReconciler(false).reconcileChildFibers;

	var internals = React__namespace.__birdge__;

	const { currentDispatcher } = internals;
	let currentRenderingFiber = null;
	let workInProgressHook = null;
	function renderWithHooks(fiber) {
	    currentRenderingFiber = fiber;
	    fiber.memoizedState = null;
	    const current = fiber.alternate;
	    if (current !== null) ;
	    else {
	        currentDispatcher.current = HooksDispatcherOnMount;
	    }
	    const Comp = fiber.type;
	    const props = fiber.pendingProps;
	    const children = Comp(props);
	    currentRenderingFiber = null;
	    return children;
	}
	const mountWorkInProgressHook = () => {
	    const hook = {
	        momoizedState: null,
	        udpateQueue: null,
	        next: null
	    };
	    if (workInProgressHook === null) {
	        if (currentRenderingFiber === null) {
	            throw new Error('call hook in fc');
	        }
	        else {
	            workInProgressHook = hook;
	            currentRenderingFiber.memoizedState = workInProgressHook;
	        }
	    }
	    else {
	        workInProgressHook.next = hook;
	        workInProgressHook = workInProgressHook.next;
	    }
	    return hook;
	};
	const dispatchSetState = (fiber, updateQueue, action) => {
	    const update = createUpdate(action);
	    enqueueUpdate(updateQueue, update);
	    scheduleUpdateOnFiber(fiber);
	};
	const mountState = (initalState) => {
	    const hook = mountWorkInProgressHook();
	    let state;
	    if (initalState instanceof Function) {
	        state = initalState();
	    }
	    else {
	        state = initalState;
	    }
	    const updateQueue = createUpdateQueue();
	    hook.udpateQueue = updateQueue;
	    const dispatch = dispatchSetState.bind(null, currentRenderingFiber, updateQueue);
	    updateQueue.dispatch = dispatch;
	    return [state, dispatch];
	};
	const HooksDispatcherOnMount = {
	    useState: mountState
	};

	const beginWork = (fiber) => {
	    switch (fiber.tag) {
	        case workTags.HostRoot:
	            return updateHostRoot(fiber);
	        case workTags.FunctionComponent:
	            return updateFunctionComponent(fiber);
	        case workTags.HostComponent:
	            return updateHostComponent(fiber);
	        case workTags.HostText:
	            return null;
	        default:
	            {
	                console.error('未实现的类型');
	            }
	    }
	    return fiber;
	};
	/**
	 *
	 * @description
	 * 对于HostRoot类型的fiber，enqueueUpdate在 updateContainer 中完成
	 * updateContainer中会把 <App/>作为update挂载 updateQueue.pending.shared 下
	 * 所以在这里拿到的memorizedState 就是 App 这个fiber
	 * @param fiber
	 * @returns
	 */
	function updateHostRoot(fiber) {
	    const baseState = fiber.memoizedState;
	    const updateQueue = fiber.updateQueue;
	    const pendingUpdateQueue = updateQueue?.shared.pending;
	    updateQueue.shared.pending = null;
	    const { memorizedState } = processUpdateQueue(baseState, pendingUpdateQueue);
	    fiber.memoizedState = memorizedState;
	    reconcileChildren(fiber, memorizedState);
	    return fiber.child;
	}
	function updateHostComponent(fiber) {
	    const children = fiber.pendingProps.children;
	    reconcileChildren(fiber, children);
	    return fiber.child;
	}
	function reconcileChildren(wipFiber, children) {
	    const current = wipFiber.alternate; //当前渲染在屏幕上的fiber结构
	    if (!current) {
	        wipFiber.child = mountChildFibers(wipFiber, null, children);
	    }
	    else {
	        wipFiber.child = reconcileChildFibers(wipFiber, current?.child, children);
	    }
	}
	function updateFunctionComponent(fiber) {
	    const children = renderWithHooks(fiber);
	    reconcileChildren(fiber, children);
	    return fiber.child;
	}

	const creatHostInstance = (type) => document.createElement(type);
	const creatHostTextInstance = (content) => document.createTextNode(content);
	const appendHostChild = (child, parent) => parent.appendChild(child);
	const appendChildToContainer = appendHostChild;

	let nextFiber = null;
	const commitMutationEffects = (finishedWork) => {
	    nextFiber = finishedWork;
	    while (nextFiber !== null) {
	        if ((nextFiber.subTreeFlags & fiberMask.Mutation) !== fiberFlags$1.NoFlags &&
	            nextFiber.child !== null) {
	            nextFiber = nextFiber.child;
	        }
	        else {
	            while (nextFiber !== null) {
	                commitMutationEffectOnFiber(nextFiber);
	                let sibling = nextFiber.sibling;
	                if (sibling !== null) {
	                    sibling = sibling.sibling;
	                    break;
	                }
	                nextFiber = nextFiber.return;
	            }
	        }
	    }
	};
	const commitMutationEffectOnFiber = (fiber) => {
	    const flags = fiber.flags;
	    if ((flags & fiberFlags$1.Placement) !== fiberFlags$1.NoFlags) {
	        commitPlacement(fiber);
	        fiber.flags &= ~fiberFlags$1.Placement;
	    }
	};
	const commitPlacement = (fiber) => {
	    const hostParent = getHostParent(fiber);
	    if (!hostParent)
	        return;
	    appendPlacementNodeIntoContainer(fiber, hostParent);
	};
	const getHostParent = (fiber) => {
	    let parent = fiber.return;
	    while (parent) {
	        if (parent.tag === workTags.HostComponent) {
	            return parent.stateNode;
	        }
	        if (parent.tag === workTags.HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    return null;
	};
	const appendPlacementNodeIntoContainer = (placementFiber, hostParent) => {
	    if (placementFiber.tag === workTags.HostComponent || placementFiber.tag === workTags.HostText) {
	        appendChildToContainer(placementFiber.stateNode, hostParent);
	        return;
	    }
	    const child = placementFiber.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling) {
	            appendChildToContainer(sibling.stateNode, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	};

	const compeleteWork = (wipFiber) => {
	    // eslint-disable-next-line @typescript-eslint/no-unused-vars
	    wipFiber.pendingProps;
	    const current = wipFiber.alternate;
	    switch (wipFiber.tag) {
	        case workTags.HostComponent:
	            if (current !== null && wipFiber.stateNode) ;
	            else {
	                // const instance = creatHostInstance(wipFiber.type, newProps)
	                const instance = creatHostInstance(wipFiber.type);
	                appendAllChildren(instance, wipFiber);
	                wipFiber.stateNode = instance;
	                bubbleFlags(wipFiber);
	            }
	            break;
	        case workTags.HostText:
	            if (current !== null && wipFiber.stateNode) ;
	            else {
	                const instance = creatHostTextInstance(wipFiber.pendingProps.text);
	                // const instance = creatHostTextInstance(wipFiber.type, newProps)
	                wipFiber.stateNode = instance;
	                bubbleFlags(wipFiber);
	            }
	            break;
	        case workTags.FunctionComponent:
	            bubbleFlags(wipFiber);
	            break;
	        case workTags.HostRoot:
	            bubbleFlags(wipFiber);
	            break;
	    }
	    return wipFiber;
	};
	function appendAllChildren(parentInstance, wipFiber) {
	    let node = wipFiber.child;
	    while (node !== null) {
	        if (node?.tag === workTags.HostComponent || node?.tag === workTags.HostText) {
	            appendHostChild(node.stateNode, parentInstance);
	        }
	        else if (node.child !== null) {
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wipFiber)
	            return;
	        while (node?.sibling === null) {
	            if (node?.return === null || node?.return === wipFiber) {
	                return;
	            }
	            //向上找到第一个有兄弟节点的fiber
	            node = node.return;
	        }
	        node.sibling.return = node.return;
	        //开始对兄弟节点进行append
	        node = node.sibling;
	    }
	}
	function bubbleFlags(wipFiber) {
	    let subTreeFlags = fiberFlags$1.NoFlags;
	    let child = wipFiber.child;
	    while (child !== null) {
	        subTreeFlags = subTreeFlags | child.subTreeFlags | child.flags;
	        child.return = wipFiber;
	        child = child.sibling;
	    }
	    wipFiber.subTreeFlags |= subTreeFlags;
	}

	let workInProgress = null;
	const prepareFreshContext = (fiberRootNode) => {
	    workInProgress = createWorkInProgress(fiberRootNode.current, {});
	};
	const scheduleUpdateOnFiber = (fiber) => {
	    const root = markUpdateFromFiberToRoot(fiber);
	    renderRoot(root);
	};
	const markUpdateFromFiberToRoot = (fiber) => {
	    let currentNode = fiber;
	    while (currentNode.return !== null) {
	        currentNode = currentNode.return;
	    }
	    if (currentNode.tag === workTags.HostRoot) {
	        return currentNode.stateNode;
	    }
	    return null;
	};
	const commitRoot = (root) => {
	    const finishedWork = root.finishedWork;
	    if (!finishedWork)
	        return;
	    root.finishedWork = null;
	    const subtreeHasEffect = (finishedWork.subTreeFlags & fiberMask.Mutation) !== fiberFlags$1.NoFlags;
	    const rootHasEffect = (finishedWork.flags & fiberMask.Mutation) !== fiberFlags$1.NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        root.current = finishedWork;
	        commitMutationEffects(finishedWork);
	    }
	    else {
	        root.current = finishedWork;
	    }
	};
	const renderRoot = (fiberRootNode) => {
	    prepareFreshContext(fiberRootNode);
	    do {
	        workLoop();
	        break;
	        // eslint-disable-next-line no-constant-condition
	    } while (true);
	    fiberRootNode.finishedWork = fiberRootNode.current.alternate;
	    if (fiberRootNode.finishedWork) {
	        commitRoot(fiberRootNode);
	    }
	};
	const workLoop = () => {
	    while (workInProgress) {
	        performUnitOfWork(workInProgress);
	    }
	};
	/**
	 *
	 * @param fiber
	 * @description 在workLoop中 performUnitOfWork 一路递归向下到最底层的子节点(CFilber)，（期间路径上的所有的节点都会执行beginWork）， 然后执行CFilber的completeUnitOfWork
	 */
	const performUnitOfWork = (fiber) => {
	    const nextFiber = beginWork(fiber);
	    fiber.memoizedPros = fiber.pendingProps;
	    if (nextFiber === null) {
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = nextFiber;
	    }
	};
	/**
	 *
	 * @param fiber
	 * @returns 在performUnitOfWork中，一旦递归到了最后的子节点fiber，那么说明这个fiber没有子节点，对这个子节点执行completeUnitOfWork
	 * 如果这个子节点有兄弟节点 ：那么结束这个fiber的 completeUnitOfWork ，把兄弟节点作为workInProgress，进入下一个workLoop中的while循环，对兄弟节点进行 performUnitOfWork
	 * 如果这个子节点没有兄弟节点 ：那么会在do while中直接一路向上对父节点执行compeleteWork，直到某个父节点有兄弟节点（PFiber），跳出completeUnitOfWork，对这个 PFiber 进行 performUnitOfWork
	 *
	 */
	const completeUnitOfWork = (fiber) => {
	    let node = fiber;
	    do {
	        compeleteWork(node);
	        const silbing = node.sibling;
	        if (silbing) {
	            workInProgress = silbing;
	            return;
	        }
	        node = node.return;
	        workInProgress = node;
	    } while (node);
	};

	/**
	 * @description
	 * createRoot时会调用，创建container
	 */
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(workTags.HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	/**
	 * @description 处理 hostRootFiber 的 updateQueue，把App组件作为 update 挂载 hostRootFiber 的 update 下
	 * @param reactElement
	 * @param root
	 * @returns
	 */
	function updateContainer(reactElement, root) {
	    const hostRootFiber = root.current;
	    const update = createUpdate(reactElement);
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    scheduleUpdateOnFiber(hostRootFiber);
	    return reactElement;
	}

	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render: (reactElement) => {
	            return updateContainer(reactElement, root);
	        }
	    };
	}

	var ReactDom = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDom;

}));
